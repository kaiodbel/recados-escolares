'use strict';

var Realm = require('realm');
var React = require('react');

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2022 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
const numericRegEx = /^-?\d+$/;
function getCacheKey(id) {
    return `${id}`;
}
/**
 * Creates a proxy around a {@link Realm.Collection} that will create new {@link Realm.Object}
 * references on any relevant change (update, insert, deletion) and return the same
 * object reference if no changes have occurred since the last access.
 *
 * This makes the {@link Realm.Collection} behaves in an immutable way, as React expects, so
 * that a {@link Realm.Object} can be wrapped in {@link React.memo} to prevent unnecessary
 * rendering (see {@link useQuery} hook).
 * @param args {@link CachedCollectionArgs} object arguments
 * @returns Proxy object wrapping the collection
 */
function createCachedCollection({ collection, realm, updateCallback, updatedRef, objectCache = new Map(), isDerived = false, keyPaths, }) {
    const cachedCollectionHandler = {
        get: function (target, key, receiver) {
            // Pass functions through
            const value = Reflect.get(target, key, receiver);
            if (typeof value === "function") {
                if (key === "sorted" || key === "filtered") {
                    return (...args) => {
                        const col = Reflect.apply(value, target, args);
                        const { collection: newCol } = createCachedCollection({
                            collection: col,
                            realm,
                            updateCallback,
                            updatedRef,
                            objectCache,
                            isDerived: true,
                            keyPaths,
                        });
                        return newCol;
                    };
                }
                return value;
            }
            // If the key is not numeric, pass it through
            if (typeof key === "symbol" || !numericRegEx.test(key)) {
                return value;
            }
            // If the key is numeric, check if we have a cached object for this key
            const index = Number(key);
            const object = target[index];
            // If the collection is modeled in a way that objects can be null
            // then we should return null instead of undefined to stay semantically
            // correct
            if (object === null) {
                return null;
            }
            else if (typeof object === "undefined") {
                // If there is no object at this index, return undefined
                return undefined;
            }
            const objectId = object._objectKey();
            const cacheKey = getCacheKey(objectId);
            // If we do, return it...
            if (objectCache.get(cacheKey)) {
                return objectCache.get(cacheKey);
            }
            // If not then this index has either not been accessed before, or has been invalidated due
            // to a modification. Fetch it from the collection and store it in the cache
            objectCache.set(cacheKey, object);
            return object;
        },
    };
    const cachedCollectionResult = new Proxy(collection, cachedCollectionHandler);
    const listenerCallback = (listenerCollection, changes) => {
        if (changes.deletions.length > 0 || changes.insertions.length > 0 || changes.newModifications.length > 0) {
            // TODO: There is currently no way to rebuild the cache key from the changes array for deleted object.
            // Until it is possible, we clear the cache on deletions.
            // Blocking issue: https://github.com/realm/realm-core/issues/5220
            // Possible solutions:
            // a. the listenerCollection is a frozen copy of the collection before the deletion,
            // allowing accessing the _objectKey() using listenerCollection[index]._objectKey()
            // b. the callback provides an array of changed objectIds
            if (changes.deletions.length > 0) {
                objectCache.clear();
            }
            // Item(s) were modified, just clear them from the cache so that we return new instances for them
            changes.newModifications.forEach((index) => {
                const objectId = listenerCollection[index]._objectKey();
                if (objectId) {
                    const cacheKey = getCacheKey(objectId);
                    if (objectCache.has(cacheKey)) {
                        objectCache.delete(cacheKey);
                    }
                }
            });
            updatedRef.current = true;
            updateCallback();
        }
    };
    let setImmediateId = undefined;
    if (!isDerived) {
        // If we are in a transaction, then push adding the listener to the event loop.  This will allow the write transaction to finish.
        // see https://github.com/realm/realm-js/issues/4375
        if (realm.isInTransaction) {
            setImmediateId = setImmediate(() => {
                collection.addListener(listenerCallback, keyPaths);
            });
        }
        else {
            collection.addListener(listenerCallback, keyPaths);
        }
    }
    const tearDown = () => {
        if (!isDerived) {
            if (setImmediateId) {
                clearImmediate(setImmediateId);
                setImmediateId = undefined;
            }
            collection.removeListener(listenerCallback);
            objectCache.clear();
        }
    };
    return { collection: cachedCollectionResult, tearDown };
}

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2022 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
/**
 * Creates a proxy around a {@link Realm.Object} that will return a new reference
 * on any relevant update to the object itself. It also wraps accesses to {@link Realm.List}
 * attributes into a {@link cachedCollection}, so that any update, insert or deletion to the
 * list will also return a new object reference.
 *
 * See {@link cachedCollection} and the `useObject` hook for description of how this
 * helps prevent unnecessary rendering.
 * @param args - {@link CachedObjectArgs} object arguments
 * @returns Proxy object wrapping the {@link Realm.Object}
 */
function createCachedObject({ object, realm, updateCallback, updatedRef, keyPaths, }) {
    const listCaches = new Map();
    const listTearDowns = [];
    // If the object doesn't exist, just return it with an noop tearDown
    //
    if (object === null) {
        return { object, tearDown: () => undefined };
    }
    // Create a cache for any Realm.List properties on the object
    for (const key of object.keys()) {
        //@ts-expect-error - TS doesn't know that the key is a valid property
        const value = object[key];
        if (value instanceof Realm.List && value.type === "object") {
            const updatedRef = { current: true };
            const { collection, tearDown } = createCachedCollection({ collection: value, realm, updateCallback, updatedRef });
            listCaches.set(key, { collection, updatedRef });
            listTearDowns.push(tearDown);
        }
    }
    // This Proxy handler intercepts any accesses into properties of the cached object
    // of type `Realm.List`, and returns a `cachedCollection` wrapping those properties
    // to allow changes in the list to trigger re-renders
    const cachedObjectHandler = {
        get: function (target, key, receiver) {
            const value = Reflect.get(target, key, receiver);
            // If its a Realm.List we need to add a proxy cache around it
            if (value instanceof Realm.List && value.type === "object") {
                if (listCaches.has(key)) {
                    // Return a new proxy wrapping the cachedCollection so that its reference gets updated,
                    // otherwise the list component will not re-render. The cachedCollection then ensures that
                    // only the modified children of the list component actually re-render.
                    const { collection, updatedRef } = listCaches.get(key);
                    if (updatedRef.current) {
                        updatedRef.current = false;
                        const proxyCollection = new Proxy(collection, {});
                        listCaches.set(key, { collection: proxyCollection, updatedRef });
                        return proxyCollection;
                    }
                    return collection;
                }
            }
            return value;
        },
    };
    const cachedObjectResult = new Proxy(object, cachedObjectHandler);
    const listenerCallback = (obj, changes) => {
        updatedRef.current = true;
        if (changes.deleted) {
            updateCallback();
        }
        else if (changes.changedProperties.length > 0) {
            // Don't force a second re-render if any of the changed properties is a Realm.List,
            // as the List's cachedCollection will force a re-render itself
            const anyListPropertyModified = changes.changedProperties.some((property) => {
                return obj[property] instanceof Realm.List && obj[property].type === "object";
            });
            const shouldRerender = !anyListPropertyModified;
            if (shouldRerender) {
                updateCallback();
            }
        }
    };
    // We cannot add a listener to an invalid object
    if (object.isValid()) {
        // If we are in a transaction, then push adding the listener to the event loop.  This will allow the write transaction to finish.
        // see https://github.com/realm/realm-js/issues/4375
        if (realm.isInTransaction) {
            setImmediate(() => {
                object.addListener(listenerCallback, keyPaths);
            });
        }
        else {
            object.addListener(listenerCallback, keyPaths);
        }
    }
    const tearDown = () => {
        object.removeListener(listenerCallback);
        for (const listTearDown of listTearDowns) {
            listTearDown();
        }
    };
    return { object: cachedObjectResult, tearDown };
}

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2023 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
// Convenience function that returns the correct type for the objectForPrimaryKey function
// Since we don't have a combined declaration for this function, typescript needs to know
// which return to use based on the typeof the type argument
function getObjectForPrimaryKey(realm, type, primaryKey) {
    return typeof type === "string"
        ? realm.objectForPrimaryKey(type, primaryKey)
        : realm.objectForPrimaryKey(type, primaryKey);
}
// Convenience function that returns the correct type for the objects function
// Since we don't have a combined declaration for this function, typescript needs to know
// which return to use based on the typeof the type argument
function getObjects(realm, type) {
    return (typeof type === "string" ? realm.objects(type) : realm.objects(type));
}
function isClassModelConstructor(value) {
    return Object.getPrototypeOf(value) === Realm.Object;
}

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2021 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
/**
 * Generates the `useObject` hook from a given `useRealm` hook.
 * @param useRealm - Hook that returns an open Realm instance
 * @returns useObject - Hook that is used to gain access to a single Realm object from a primary key
 */
function createUseObject(useRealm) {
    function useObject(type, primaryKey, keyPaths) {
        const realm = useRealm();
        // Create a forceRerender function for the cachedObject to use as its updateCallback, so that
        // the cachedObject can force the component using this hook to re-render when a change occurs.
        const [, forceRerender] = React.useReducer((x) => x + 1, 0);
        // Get the original object from the realm, so we can check if it exists
        const originalObject = getObjectForPrimaryKey(realm, type, primaryKey);
        // Store the primaryKey as a ref, since when it is an objectId or UUID, it will be a new instance on every render
        const primaryKeyRef = React.useRef(primaryKey);
        const collectionRef = React.useRef(getObjects(realm, type));
        const objectRef = React.useRef();
        const updatedRef = React.useRef(true);
        // Initializing references with a function call or class constructor will
        // cause the function or constructor to be called on ever render.
        // Even though this value is thrown away on subsequent renders, `createCachedObject` will end up registering a listener.
        // Therefore, we initialize the references with null, and only create the object if it is null
        // Ref: https://github.com/facebook/react/issues/14490
        const cachedObjectRef = React.useRef(null);
        const memoizedKeyPaths = React.useMemo(() => (typeof keyPaths === "string" ? [keyPaths] : keyPaths), 
        /* eslint-disable-next-line react-hooks/exhaustive-deps -- Memoizing the keyPaths to avoid renders */
        [JSON.stringify(keyPaths)]);
        if (!cachedObjectRef.current) {
            cachedObjectRef.current = createCachedObject({
                object: originalObject ?? null,
                realm,
                updateCallback: forceRerender,
                updatedRef,
                keyPaths: memoizedKeyPaths,
            });
        }
        // Create a ref, since the object returned from `objectForPrimaryKey` is always going to have a different reference
        const originalObjectRef = React.useRef(originalObject);
        // Wrap the cachedObject in useMemo, so we only replace it with a new instance if `primaryKey` or `type` change
        const { object, tearDown } = React.useMemo(
        // TODO: There will be an upcoming breaking change that makes objectForPrimaryKey return null
        // When this is implemented, remove `?? null`
        () => {
            // This should never happen, but if it does, we want to return a null result
            if (!cachedObjectRef.current) {
                return { object: null, tearDown: () => undefined };
            }
            // Re-instantiate the cachedObject if the primaryKey has changed or the originalObject has gone from null to not null
            if (!arePrimaryKeysIdentical(primaryKey, primaryKeyRef.current) ||
                (!originalObjectRef.current && originalObject)) {
                cachedObjectRef.current = createCachedObject({
                    object: originalObject ?? null,
                    realm,
                    updateCallback: forceRerender,
                    updatedRef,
                    keyPaths: memoizedKeyPaths,
                });
                originalObjectRef.current = originalObject;
                // Primary key has updated, so update the reference
                primaryKeyRef.current = primaryKey;
                // Signal that the object reference needs to be updated
                updatedRef.current = true;
            }
            return cachedObjectRef.current;
        }, [realm, originalObject, primaryKey, memoizedKeyPaths]);
        // Invoke the tearDown of the cachedObject when useObject is unmounted
        React.useEffect(() => {
            return tearDown;
        }, [tearDown]);
        // If the object doesn't exist, listen for insertions to the collection and force a rerender if the inserted object has the correct primary key
        React.useEffect(() => {
            const collection = collectionRef.current;
            const collectionListener = (_, changes) => {
                const primaryKeyProperty = collection?.[0]?.objectSchema()?.primaryKey;
                for (const index of changes.insertions) {
                    const object = collection[index];
                    if (primaryKeyProperty) {
                        //@ts-expect-error - if the primaryKeyProperty exists, then it is indexable. However, we don't allow it when we don't actually know the type of the object
                        const insertedPrimaryKey = object[primaryKeyProperty];
                        if (arePrimaryKeysIdentical(insertedPrimaryKey, primaryKeyRef.current)) {
                            forceRerender();
                            collection.removeListener(collectionListener);
                            break;
                        }
                    }
                }
            };
            if (!originalObjectRef.current) {
                collection.addListener(collectionListener);
            }
            return () => {
                // If the app is closing, the realm will be closed and the listener does not need to be removed if
                if (!realm.isClosed && collection) {
                    collection.removeListener(collectionListener);
                }
            };
        }, [realm, type, forceRerender]);
        // If the object has been deleted or doesn't exist for the given primary key, just return null
        if (!object?.isValid()) {
            return null;
        }
        if (updatedRef.current) {
            // Wrap object in a proxy to update the reference on rerender ( should only rerender when something has changed )
            objectRef.current = new Proxy(object, {});
            updatedRef.current = false;
        }
        // This will never be undefined, but the type system doesn't know that
        return objectRef.current;
    }
    return function useObjectOverload(typeOrOptions, primaryKey, keyPaths) {
        if (typeof typeOrOptions === "string" || isClassModelConstructor(typeOrOptions)) {
            if (typeof primaryKey === "undefined") {
                throw new Error("Expected a primary key");
            }
            /* eslint-disable-next-line react-hooks/rules-of-hooks -- We're calling `useQuery` once in any of the brances */
            return useObject(typeOrOptions, primaryKey, keyPaths);
        }
        else {
            const { type, primaryKey, keyPaths } = typeOrOptions;
            /* eslint-disable-next-line react-hooks/rules-of-hooks -- We're calling `useQuery` once in any of the brances */
            return useObject(type, primaryKey, keyPaths);
        }
    };
}
// This is a helper function that determines if two primary keys are equal.  It will also handle the case where the primary key is an ObjectId or UUID
function arePrimaryKeysIdentical(a, b) {
    if (typeof a !== typeof b) {
        return false;
    }
    if (typeof a === "string" || typeof a === "number") {
        return a === b;
    }
    if (a instanceof Realm.BSON.ObjectId && b instanceof Realm.BSON.ObjectId) {
        return a.toHexString() === b.toHexString();
    }
    if (a instanceof Realm.BSON.UUID && b instanceof Realm.BSON.UUID) {
        return a.toHexString() === b.toHexString();
    }
    return false;
}

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2021 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
/**
 * Maps a value to itself
 */
function identity(value) {
    return value;
}
/**
 * Generates the `useQuery` hook from a given `useRealm` hook.
 * @param useRealm - Hook that returns an open Realm instance
 * @returns useObject - Hook that is used to gain access to a {@link Realm.Collection}
 */
function createUseQuery(useRealm) {
    function useQuery({ type, query = identity, keyPaths }, deps = []) {
        const realm = useRealm();
        // We need to add the type to the deps, so that if the type changes, the query will be re-run.
        // This will be saved in an array which will be spread into the provided deps.
        const requiredDeps = [type];
        // Create a forceRerender function for the cachedCollection to use as its updateCallback, so that
        // the cachedCollection can force the component using this hook to re-render when a change occurs.
        const [, forceRerender] = React.useReducer((x) => x + 1, 0);
        const collectionRef = React.useRef();
        const updatedRef = React.useRef(true);
        const queryCallbackRef = React.useRef(null);
        /* eslint-disable-next-line react-hooks/exhaustive-deps -- We want the user of this hook to be able pass in the `query` function inline (without the need to `useCallback` on it)
        This means that the query function is unstable and will be a redefined on each render of the component where `useQuery` is used
        Therefore we use the `deps` array to memoize the query function internally, and only use the returned `queryCallback` */
        const queryCallback = React.useCallback(query, [...deps, ...requiredDeps]);
        // If the query function changes, we need to update the cachedCollection
        if (queryCallbackRef.current !== queryCallback) {
            queryCallbackRef.current = queryCallback;
            updatedRef.current = true;
        }
        const queryResult = React.useMemo(() => {
            return queryCallback(getObjects(realm, type));
        }, [type, realm, queryCallback]);
        const memoizedKeyPaths = React.useMemo(() => (typeof keyPaths === "string" ? [keyPaths] : keyPaths), 
        /* eslint-disable-next-line react-hooks/exhaustive-deps -- Memoizing the keyPaths to avoid renders */
        [JSON.stringify(keyPaths)]);
        // Wrap the cachedObject in useMemo, so we only replace it with a new instance if `realm` or `queryResult` change
        const { collection, tearDown } = React.useMemo(() => {
            return createCachedCollection({
                collection: queryResult,
                realm,
                updateCallback: forceRerender,
                updatedRef,
                keyPaths: memoizedKeyPaths,
            });
        }, [realm, queryResult, memoizedKeyPaths]);
        // Invoke the tearDown of the cachedCollection when useQuery is unmounted
        React.useEffect(() => {
            return tearDown;
        }, [tearDown]);
        // This makes sure the collection has a different reference on a rerender
        // Also we are ensuring the type returned is Realm.Results, as this is known in this context
        if (updatedRef.current) {
            updatedRef.current = false;
            collectionRef.current = new Proxy(collection, {});
        }
        // This will never not be defined, but the type system doesn't know that
        return collectionRef.current;
    }
    return function useQueryOverload(typeOrOptionsOrQuery, queryOrDeps = identity, depsOrPartialOptions = []) {
        const args = { typeOrOptionsOrQuery, queryOrDeps, depsOrPartialOptions };
        /* eslint-disable react-hooks/rules-of-hooks -- We're calling `useQuery` once in any of the brances */
        if (isTypeFunctionDeps(args)) {
            return useQuery({ type: args.typeOrOptionsOrQuery, query: args.queryOrDeps }, args.depsOrPartialOptions);
        }
        if (isOptionsDepsNone(args)) {
            return useQuery(args.typeOrOptionsOrQuery, Array.isArray(args.queryOrDeps) ? args.queryOrDeps : []);
        }
        if (isFunctionDepsOptions(args)) {
            return useQuery({ ...args.depsOrPartialOptions, query: args.typeOrOptionsOrQuery }, args.queryOrDeps);
        }
        /* eslint-enable react-hooks/rules-of-hooks */
        throw new Error("Unexpected arguments passed to useQuery");
    };
}
function isTypeFunctionDeps(args) {
    const { typeOrOptionsOrQuery, queryOrDeps, depsOrPartialOptions } = args;
    return ((typeof typeOrOptionsOrQuery === "string" || isClassModelConstructor(typeOrOptionsOrQuery)) &&
        typeof queryOrDeps === "function" &&
        Array.isArray(depsOrPartialOptions));
}
function isOptionsDepsNone(args) {
    const { typeOrOptionsOrQuery, queryOrDeps } = args;
    return (typeof typeOrOptionsOrQuery === "object" &&
        typeOrOptionsOrQuery !== null &&
        (Array.isArray(queryOrDeps) || queryOrDeps === identity));
}
function isFunctionDepsOptions(args) {
    const { typeOrOptionsOrQuery, queryOrDeps, depsOrPartialOptions } = args;
    return (typeof typeOrOptionsOrQuery === "function" &&
        Array.isArray(queryOrDeps) &&
        typeof depsOrPartialOptions === "object" &&
        depsOrPartialOptions !== null);
}

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2021 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
/**
 * Generates a `useRealm` hook given a RealmContext.  This allows access to the {@link Realm}
 * instance anywhere within the RealmProvider.
 * @param RealmContext - The context containing the {@link Realm} instance
 * @returns useRealm - Hook that is used to gain access to the {@link Realm} instance
 */
const createUseRealm = (RealmContext) => {
    return function useRealm() {
        // This is the context setup by `createRealmContext`
        const context = React.useContext(RealmContext);
        if (context === null) {
            throw new Error("Realm context not found.  Did you call useRealm() within a <RealmProvider/>?");
        }
        return context;
    };
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var lodash_isequal = {exports: {}};

/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
lodash_isequal.exports;

(function (module, exports) {
	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    asyncTag = '[object AsyncFunction]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    nullTag = '[object Null]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    proxyTag = '[object Proxy]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]',
	    undefinedTag = '[object Undefined]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/** Detect free variable `exports`. */
	var freeExports = exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	/** Used for built-in method references. */
	var arrayProto = Array.prototype,
	    funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined,
	    Symbol = root.Symbol,
	    Uint8Array = root.Uint8Array,
	    propertyIsEnumerable = objectProto.propertyIsEnumerable,
	    splice = arrayProto.splice,
	    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols,
	    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
	    nativeKeys = overArg(Object.keys, Object);

	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView'),
	    Map = getNative(root, 'Map'),
	    Promise = getNative(root, 'Promise'),
	    Set = getNative(root, 'Set'),
	    WeakMap = getNative(root, 'WeakMap'),
	    nativeCreate = getNative(Object, 'create');

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	  this.size = 0;
	}

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
	}

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	  this.size = 0;
	}

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache) {
	    var pairs = data.__data__;
	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	}

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	}

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = objIsArr ? arrayTag : getTag(object),
	      othTag = othIsArr ? arrayTag : getTag(other);

	  objTag = objTag == argsTag ? objectTag : objTag;
	  othTag = othTag == argsTag ? objectTag : othTag;

	  var objIsObj = objTag == objectTag,
	      othIsObj = othTag == objectTag,
	      isSameTag = objTag == othTag;

	  if (isSameTag && isBuffer(object)) {
	    if (!isBuffer(other)) {
	      return false;
	    }
	    objIsArr = true;
	    objIsObj = false;
	  }
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }
	  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(array);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!cacheHas(seen, othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	              return seen.push(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, bitmask, customizer, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	        return false;
	      }
	      return true;

	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);

	    case errorTag:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag:
	      var convert = mapToArray;

	    case setTag:
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
	      convert || (convert = setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= COMPARE_UNORDERED_FLAG;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      objProps = getAllKeys(object),
	      objLength = objProps.length,
	      othProps = getAllKeys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	      return false;
	    }
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(object);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys(object) {
	  return baseGetAllKeys(object, keys, getSymbols);
	}

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return arrayFilter(nativeGetSymbols(object), function(symbol) {
	    return propertyIsEnumerable.call(object, symbol);
	  });
	};

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map && getTag(new Map) != mapTag) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	  getTag = function(value) {
	    var result = baseGetTag(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : '';

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;

	/**
	 * Performs a deep comparison between two values to determine if they are
	 * equivalent.
	 *
	 * **Note:** This method supports comparing arrays, array buffers, booleans,
	 * date objects, error objects, maps, numbers, `Object` objects, regexes,
	 * sets, strings, symbols, and typed arrays. `Object` objects are compared
	 * by their own, not inherited, enumerable properties. Functions and DOM
	 * nodes are compared by strict equality, i.e. `===`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.isEqual(object, other);
	 * // => true
	 *
	 * object === other;
	 * // => false
	 */
	function isEqual(value, other) {
	  return baseIsEqual(value, other);
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */
	function stubArray() {
	  return [];
	}

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	module.exports = isEqual; 
} (lodash_isequal, lodash_isequal.exports));

var lodash_isequalExports = lodash_isequal.exports;
var isEqual = /*@__PURE__*/getDefaultExportFromCjs(lodash_isequalExports);

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2023 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
exports.AuthOperationName = void 0;
(function (AuthOperationName) {
    AuthOperationName["LogIn"] = "logIn";
    AuthOperationName["LogInWithAnonymous"] = "logInWithAnonymous";
    AuthOperationName["LogInWithApiKey"] = "logInWithApiKey";
    AuthOperationName["LogInWithEmailPassword"] = "logInWithEmailPassword";
    AuthOperationName["LogInWithJWT"] = "logInWithJWT";
    AuthOperationName["LogInWithGoogle"] = "logInWithGoogle";
    AuthOperationName["LogInWithApple"] = "logInWithApple";
    AuthOperationName["LogInWithFacebook"] = "logInWithFacebook";
    AuthOperationName["LogInWithFunction"] = "logInWithFunction";
    AuthOperationName["LogOut"] = "logOut";
    AuthOperationName["Register"] = "register";
    AuthOperationName["Confirm"] = "confirm";
    AuthOperationName["ResendConfirmationEmail"] = "resendConfirmationEmail";
    AuthOperationName["RetryCustomConfirmation"] = "retryCustomConfirmation";
    AuthOperationName["SendResetPasswordEmail"] = "sendResetPasswordEmail";
    AuthOperationName["ResetPassword"] = "resetPassword";
    AuthOperationName["CallResetPasswordFunction"] = "callResetPasswordFunction";
})(exports.AuthOperationName || (exports.AuthOperationName = {}));
/**
 * The `AuthError` is set based on the operation name and the error message.
 */
class AuthError extends Error {
    constructor(operation, message) {
        super(message);
        this.name = "AuthError";
        this.operation = operation;
    }
}
/**
 * The possible states an {@link OperationResult} can be in.
 */
exports.OperationState = void 0;
(function (OperationState) {
    OperationState["NotStarted"] = "not-started";
    OperationState["Pending"] = "pending";
    OperationState["Success"] = "success";
    OperationState["Error"] = "error";
})(exports.OperationState || (exports.OperationState = {}));

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2022 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
/**
 * Create a context containing the Realm app.  Should be accessed with the useApp hook.
 */
const AppContext = React.createContext(null);
const AuthOperationContext = React.createContext(null);
const AuthOperationProvider = ({ children }) => {
    const [authOpResult, setAuthOpResult] = React.useState({
        state: exports.OperationState.NotStarted,
        pending: false,
        success: false,
        error: undefined,
        operation: null,
    });
    return (React.createElement(AuthOperationContext.Provider, { value: [authOpResult, setAuthOpResult] }, children));
};
function AppProvider({ children, app, ...config }) {
    if (app instanceof Realm.App) {
        if (Object.keys(config).length > 0) {
            throw new Error("Cannot use configuration props when using an existing App instance.");
        }
        return React.createElement(AppProviderWithApp, { app: app }, children);
    }
    else if (typeof app !== "undefined") {
        throw new Error(`The "app" prop is used to pass an existing Realm.App instance into an AppProvider. Either remove it or pass a valid Realm.App.`);
    }
    return (React.createElement(AppProviderWithConfiguration, { ...config }, children));
}
function AppProviderWithApp({ app, children }) {
    return (React.createElement(AppContext.Provider, { value: app },
        React.createElement(AuthOperationProvider, null, children)));
}
function AppProviderWithConfiguration({ appRef, children, ...config }) {
    const configRef = React.useRef(config);
    const [app, setApp] = React.useState(() => new Realm.App(configRef.current));
    // Support for a possible change in configuration
    if (!isEqual(config, configRef.current)) {
        configRef.current = config;
        try {
            setApp(new Realm.App(configRef.current));
        }
        catch (err) {
            console.error(err);
        }
    }
    React.useLayoutEffect(() => {
        if (appRef) {
            appRef.current = app;
        }
    }, [appRef, app]);
    return (React.createElement(AppContext.Provider, { value: app },
        React.createElement(AuthOperationProvider, null, children)));
}
/**
 * Hook to access the current {@link Realm.App} from the {@link AppProvider} context.
 * @throws if an AppProvider does not exist in the components ancestors
 */
const useApp = () => {
    const app = React.useContext(AppContext);
    if (!app) {
        throw new Error("No app found. Did you forget to wrap your component in an <AppProvider>?");
    }
    return app;
};
const useAuthResult = () => {
    const authOperationStateHook = React.useContext(AuthOperationContext);
    if (!authOperationStateHook) {
        throw new Error("Auth operation statue could not be determined. Did you forget to wrap your component in an <AppProvider>?");
    }
    return authOperationStateHook;
};

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2022 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
/**
 * Create a context containing the Realm app.  Should be accessed with the useApp hook.
 */
const UserContext = React.createContext(null);
function userWasUpdated(userA, userB) {
    if (!userA && !userB) {
        return false;
    }
    else if (userA && userB) {
        return (userA.id !== userB.id ||
            userA.state !== userB.state ||
            userA.accessToken !== userB.accessToken ||
            userA.refreshToken !== userB.refreshToken);
    }
    else {
        return true;
    }
}
/**
 * React component providing a Realm user on the context for the sync hooks
 * to use. A `UserProvider` is required for an app to use the hooks.
 */
const UserProvider = ({ fallback: Fallback, children }) => {
    const app = useApp();
    const [user, setUser] = React.useState(() => app.currentUser);
    const [, forceUpdate] = React.useReducer((x) => x + 1, 0);
    // Support for a possible change in configuration.
    // Do the check here rather than in a `useEffect()` so as to not render stale state. This allows
    // for the rerender to restart without also having to rerender the children using the stale state.
    const currentUser = app.currentUser;
    if (userWasUpdated(user, currentUser)) {
        setUser(currentUser);
    }
    React.useEffect(() => {
        app.addListener(forceUpdate);
        return () => app.removeListener(forceUpdate);
    }, [app]);
    React.useEffect(() => {
        user?.addListener(forceUpdate);
        return () => user?.removeListener(forceUpdate);
        /*
          eslint-disable-next-line react-hooks/exhaustive-deps
          -- We should depend on `user.id` rather than `user` as the ID will indicate a new user in this case.
        */
    }, [user?.id]);
    if (!user) {
        if (typeof Fallback === "function") {
            return React.createElement(Fallback, null);
        }
        return React.createElement(React.Fragment, null, Fallback);
    }
    return React.createElement(UserContext.Provider, { value: user }, children);
};
/**
 * Hook to access the currently authenticated Realm user from the
 * {@link UserProvider} context. The user is stored as React state,
 * so will trigger a re-render whenever it changes (e.g. logging in,
 * logging out, switching user).
 *
 */
const useUser = () => {
    const user = React.useContext(UserContext);
    if (!user) {
        throw new Error("No user found. Did you forget to wrap your component in a <UserProvider>?");
    }
    return user;
};

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2021 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
function createRealmProviderFromRealm(realm, RealmContext) {
    return ({ children }) => {
        return React.createElement(RealmContext.Provider, { value: realm, children: children });
    };
}
/**
 * Generates a `RealmProvider` given a {@link Realm.Configuration} and {@link React.Context}.
 * @param realmConfig - The configuration of the Realm to be instantiated
 * @param RealmContext - The context that will contain the Realm instance
 * @returns a RealmProvider component that provides context to all context hooks
 */
function createRealmProviderFromConfig(realmConfig, RealmContext) {
    return ({ children, fallback: Fallback, closeOnUnmount = true, realmRef, ...restProps }) => {
        const [realm, setRealm] = React.useState(() => realmConfig.sync === undefined && restProps.sync === undefined
            ? new Realm(mergeRealmConfiguration(realmConfig, restProps))
            : null);
        // Automatically set the user in the configuration if its been set.
        // Grabbing directly from the context to avoid throwing an error if the user is not set.
        const user = React.useContext(UserContext);
        // We increment `configVersion` when a config override passed as a prop
        // changes, which triggers a `useEffect` to re-open the Realm with the
        // new config
        const [configVersion, setConfigVersion] = React.useState(0);
        // We put realm in a ref to avoid have an endless loop of updates when the realm is updated
        const currentRealm = React.useRef(realm);
        // This will merge the configuration provided by createRealmContext and any configuration properties
        // set directly on the RealmProvider component.  Any settings on the component will override the original configuration.
        const configuration = React.useRef(mergeRealmConfiguration(realmConfig, restProps));
        // Merge and set the configuration again and increment the version if any
        // of the RealmProvider properties change.
        React.useEffect(() => {
            const combinedConfig = mergeRealmConfiguration(realmConfig, restProps);
            // If there is a user in the current context and not one set by the props, then use the one from context
            const combinedConfigWithUser = combinedConfig?.sync && user ? mergeRealmConfiguration({ sync: { user } }, combinedConfig) : combinedConfig;
            if (!areConfigurationsIdentical(configuration.current, combinedConfigWithUser)) {
                configuration.current = combinedConfigWithUser;
                // Only rerender if realm has already been configured
                if (currentRealm.current != null) {
                    setConfigVersion((x) => x + 1);
                }
            }
        }, [restProps, user]);
        React.useEffect(() => {
            currentRealm.current = realm;
            if (realmRef) {
                realmRef.current = realm;
            }
        }, [realm]);
        const [progress, setProgress] = React.useState(0);
        React.useEffect(() => {
            const realmRef = currentRealm.current;
            // Check if we currently have an open Realm. If we do not (i.e. it is the first
            // render, or the Realm has been closed due to a config change), then we
            // need to open a new Realm.
            const shouldInitRealm = realmRef === null;
            const initRealm = async () => {
                const openRealm = await Realm.open(configuration.current).progress((estimate) => {
                    setProgress(estimate);
                });
                setRealm(openRealm);
            };
            if (shouldInitRealm) {
                initRealm().catch(console.error);
            }
            return () => {
                if (realm) {
                    if (closeOnUnmount) {
                        realm.close();
                    }
                    setRealm(null);
                }
            };
        }, [configVersion, realm, setRealm, closeOnUnmount]);
        if (!realm) {
            if (typeof Fallback === "function") {
                return React.createElement(Fallback, { progress: progress });
            }
            return React.createElement(React.Fragment, null, Fallback);
        }
        return React.createElement(RealmContext.Provider, { value: realm, children: children });
    };
}
/**
 * Generates a `RealmProvider` which is either based on a configuration
 * or based on a realm, depending on its props.
 * @param RealmContext - The context that will contain the Realm instance
 * @returns a RealmProvider component that provides context to all context hooks
 */
function createDynamicRealmProvider(RealmContext) {
    const RealmProviderFromConfig = createRealmProviderFromConfig({}, RealmContext);
    return ({ realm, children, ...config }) => {
        if (realm) {
            if (Object.keys(config).length > 0) {
                throw new Error("Cannot use configuration props when using an existing Realm instance.");
            }
            return React.createElement(RealmContext.Provider, { value: realm, children: children });
        }
        else {
            return React.createElement(RealmProviderFromConfig, { ...config, children: children });
        }
    };
}
/**
 * Generates the appropriate `RealmProvider` based on whether there is a config, realm, or neither given.
 * @param realmOrConfig - A Realm instance, a configuration, or undefined (including default provider).
 * @param RealmContext - The context that will contain the Realm instance
 * @returns a RealmProvider component that provides context to all context hooks
 */
function createRealmProvider(realmOrConfig, RealmContext) {
    if (!realmOrConfig) {
        return createDynamicRealmProvider(RealmContext);
    }
    else if (realmOrConfig instanceof Realm) {
        return createRealmProviderFromRealm(realmOrConfig, RealmContext);
    }
    else {
        return createRealmProviderFromConfig(realmOrConfig, RealmContext);
    }
}
/**
 * Merge two configurations, creating a configuration using `configA` as the default,
 * merged with `configB`, with properties in `configB` overriding `configA`.
 * @param configA - The default config object
 * @param configB - Config overrides object
 * @returns Merged config object
 */
function mergeRealmConfiguration(configA, configB) {
    // In order to granularly update sync properties on the RealmProvider, sync must be
    // seperately applied to the configuration.  This allows for dynamic updates to the
    // partition field.
    const sync = { ...configA.sync, ...configB.sync };
    return {
        ...configA,
        ...configB,
        //TODO: When Realm >= 10.9.0 is a peer dependency, we can simply spread sync here
        //See issue #4012
        ...(Object.keys(sync).length > 0 ? { sync } : undefined),
    };
}
/**
 * Utility function that does a deep comparison (key: value) of object a with object b
 * @param a - Object to compare
 * @param b - Object to compare
 * @returns True if the objects are identical
 */
function areConfigurationsIdentical(a, b) {
    return isEqual(a, b);
}

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2023 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
function createUseProgress(useRealm) {
    return function useProgress({ direction, mode }) {
        const realm = useRealm();
        const [progress, setProgress] = React.useState(null);
        React.useEffect(() => {
            if (!realm.syncSession) {
                throw new Error("No sync session found.");
            }
            const callback = (estimate) => {
                setProgress(estimate);
            };
            realm.syncSession.addProgressNotification(direction, mode, callback);
            return () => realm.syncSession?.removeProgressNotification(callback);
        }, [realm, direction, mode]);
        return progress;
    };
}

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2024 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
function createRealmContext(realmOrConfig) {
    const RealmContext = React.createContext(realmOrConfig instanceof Realm ? realmOrConfig : null);
    const RealmProvider = createRealmProvider(realmOrConfig, RealmContext);
    const useRealm = createUseRealm(RealmContext);
    const useQuery = createUseQuery(useRealm);
    const useObject = createUseObject(useRealm);
    const useProgress = createUseProgress(useRealm);
    return {
        RealmProvider,
        useRealm,
        useQuery,
        useObject,
        useProgress,
    };
}

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2023 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
function useAuthOperation({ operation, operationName, }) {
    const [result, setResult] = useAuthResult();
    return React.useCallback((...args) => {
        if (result.pending) {
            return Promise.reject("Another authentication operation is already in progress");
        }
        setResult({
            state: exports.OperationState.Pending,
            pending: true,
            success: false,
            error: undefined,
            operation: operationName,
        });
        operation(...args).then(() => {
            setResult({
                state: exports.OperationState.Success,
                pending: false,
                success: true,
                error: undefined,
                operation: operationName,
            });
        }, (error) => {
            const authError = new AuthError(operationName, error);
            setResult({
                state: exports.OperationState.Error,
                pending: false,
                success: false,
                error: authError,
                operation: operationName,
            });
        });
    }, [result, setResult, operation, operationName]);
}

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2023 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
/**
 * Hook providing operations and corresponding state for authenticating with an
 * Atlas App.
 *
 * The {@link AuthResult} values returned from this hook (e.g. `state`, `pending`, etc.) are
 * shared across all components under a given `AppProvider`, as only one operation can be in
 * progress at a given time (i.e. we will store the values on the context). This means that,
 * for example, multiple components can use the `useAuth` hook to access
 * `loginResult.pending` to render a spinner when login is in progress, without
 * needing to pass that state around or store it somewhere global in their app
 * code.
 * @returns An object containing operations and state for authenticating with an Atlas App.
 */
function useAuth() {
    const app = useApp();
    const [result] = useAuthResult();
    const logIn = useAuthOperation({
        operation: React.useCallback((credentials) => app.logIn(credentials), [app]),
        operationName: exports.AuthOperationName.LogIn,
    });
    const logInWithAnonymous = useAuthOperation({
        operation: React.useCallback(() => app.logIn(Realm.Credentials.anonymous()), [app]),
        operationName: exports.AuthOperationName.LogInWithAnonymous,
    });
    const logInWithApiKey = useAuthOperation({
        operation: React.useCallback((key) => app.logIn(Realm.Credentials.apiKey(key)), [app]),
        operationName: exports.AuthOperationName.LogInWithApiKey,
    });
    const logInWithEmailPassword = useAuthOperation({
        operation: React.useCallback((params) => app.logIn(Realm.Credentials.emailPassword(params.email, params.password)), [app]),
        operationName: exports.AuthOperationName.LogInWithEmailPassword,
    });
    const logInWithJWT = useAuthOperation({
        operation: React.useCallback((token) => app.logIn(Realm.Credentials.jwt(token)), [app]),
        operationName: exports.AuthOperationName.LogInWithJWT,
    });
    const logInWithGoogle = useAuthOperation({
        operation: React.useCallback((credentials) => app.logIn(Realm.Credentials.google(credentials)), [app]),
        operationName: exports.AuthOperationName.LogInWithGoogle,
    });
    const logInWithApple = useAuthOperation({
        operation: React.useCallback((idToken) => app.logIn(Realm.Credentials.apple(idToken)), [app]),
        operationName: exports.AuthOperationName.LogInWithApple,
    });
    const logInWithFacebook = useAuthOperation({
        operation: React.useCallback((accessToken) => app.logIn(Realm.Credentials.facebook(accessToken)), [app]),
        operationName: exports.AuthOperationName.LogInWithFacebook,
    });
    const logInWithFunction = useAuthOperation({
        operation: React.useCallback((payload) => app.logIn(Realm.Credentials.function(payload)), [app]),
        operationName: exports.AuthOperationName.LogInWithFunction,
    });
    const logOut = useAuthOperation({
        operation: React.useCallback(async () => app.currentUser?.logOut(), [app]),
        operationName: exports.AuthOperationName.LogOut,
    });
    return {
        result,
        logIn,
        logInWithAnonymous,
        logInWithApiKey,
        logInWithEmailPassword,
        logInWithJWT,
        logInWithGoogle,
        logInWithApple,
        logInWithFacebook,
        logInWithFunction,
        logOut,
    };
}

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2023 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
/**
 * Hook providing operations and corresponding state for authenticating with an
 * Atlas App with Email/Password.  It also contains operations related to
 * Email/Password authentication, such as resetting password and confirming a user.
 *
 * The {@link AuthResult} values returned from this hook (e.g. `state`, `pending`, etc.) are
 * shared across all components under a given `AppProvider`, as only one operation can be in
 * progress at a given time (i.e. we will store the values on the context). This means that,
 * for example, multiple components can use the `useEmailPasswordAuth` hook to access
 * `result.pending` to render a spinner when login is in progress, without
 * needing to pass that state around or store it somewhere global in their app
 * code.
 * @returns An object containing operations and state related to Email/Password authentication.
 */
function useEmailPasswordAuth() {
    const app = useApp();
    const [result] = useAuthResult();
    const logIn = useAuthOperation({
        operation: React.useCallback((credentials) => app.logIn(Realm.Credentials.emailPassword(credentials)), [app]),
        operationName: exports.AuthOperationName.LogIn,
    });
    const register = useAuthOperation({
        operation: React.useCallback((credentials) => app.emailPasswordAuth.registerUser(credentials), [app]),
        operationName: exports.AuthOperationName.Register,
    });
    const confirm = useAuthOperation({
        operation: React.useCallback((args) => app.emailPasswordAuth.confirmUser(args), [app]),
        operationName: exports.AuthOperationName.Confirm,
    });
    const resendConfirmationEmail = useAuthOperation({
        operation: React.useCallback((args) => app.emailPasswordAuth.resendConfirmationEmail(args), [app]),
        operationName: exports.AuthOperationName.ResendConfirmationEmail,
    });
    const retryCustomConfirmation = useAuthOperation({
        operation: React.useCallback((args) => app.emailPasswordAuth.retryCustomConfirmation(args), [app]),
        operationName: exports.AuthOperationName.RetryCustomConfirmation,
    });
    const sendResetPasswordEmail = useAuthOperation({
        operation: React.useCallback((args) => app.emailPasswordAuth.sendResetPasswordEmail(args), [app]),
        operationName: exports.AuthOperationName.SendResetPasswordEmail,
    });
    const callResetPasswordFunction = useAuthOperation({
        operation: React.useCallback((credentials, ...restArgs) => app.emailPasswordAuth.callResetPasswordFunction(credentials, ...restArgs), [app]),
        operationName: exports.AuthOperationName.CallResetPasswordFunction,
    });
    const resetPassword = useAuthOperation({
        operation: (args) => app.emailPasswordAuth.resetPassword(args),
        operationName: exports.AuthOperationName.ResetPassword,
    });
    const logOut = useAuthOperation({
        operation: async () => app.currentUser?.logOut(),
        operationName: exports.AuthOperationName.LogOut,
    });
    return {
        result,
        logIn,
        register,
        resendConfirmationEmail,
        confirm,
        retryCustomConfirmation,
        sendResetPasswordEmail,
        callResetPasswordFunction,
        resetPassword,
        logOut,
    };
}

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2021 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
const defaultContext = createRealmContext();
/**
 * The Provider component that is required to wrap any component using
 * the Realm hooks.
 * @example
 * ```
 * const AppRoot = () => {
 *   const syncConfig = {
 *     flexible: true,
 *     user: currentUser
 *   };
 *
 *   return (
 *     <RealmProvider schema={[Task, User]} path={"data.realm"} sync={syncConfig}>
 *       <App/>
 *     </RealmProvider>
 *   )
 * }
 * ```
 * @example
 *  const syncConfig = {
 *     flexible: true,
 *     user: currentUser
 *   };
 *  const realm = new Realm(schema:[Task, User], path:"data.realm", sync: syncConfig);
 *  ...
 *  const AppRoot = () => {
 *   return (
 *     <RealmProvider>
 *       <App/>
 *     </RealmProvider>
 *   )
 * }
 * @param props - The {@link Realm.Configuration} or {@link Realm} for this Provider, passed as props.
 */
const RealmProvider = defaultContext.RealmProvider;
/**
 * Returns the instance of the {@link Realm} opened by the `RealmProvider`.
 * @example
 * ```
 * const realm = useRealm();
 * ```
 * @returns a realm instance
 */
const useRealm = defaultContext.useRealm;
/**
 * Returns a {@link Realm.Collection} of {@link Realm.Object}s from a given type.
 * The hook will update on any changes to any object in the collection.
 *
 * The result of this can be consumed directly by the `data` argument of any React Native
 * VirtualizedList or FlatList.  If the component used for the list's `renderItem` prop is {@link React.Memo}ized,
 * then only the modified object will re-render.
 * @example
 * ```tsx
 * // Return all collection items
 * const collection = useQuery({ type: Object });
 *
 * // Return all collection items sorted by name and filtered by category
 * const filteredAndSorted = useQuery({
 *   type: Object,
 *   query: (collection) => collection.filtered('category == $0',category).sorted('name'),
 * }, [category]);
 *
 * // Return all collection items sorted by name and filtered by category, triggering re-renders only if "name" changes
 * const filteredAndSorted = useQuery({
 *   type: Object,
 *   query: (collection) => collection.filtered('category == $0',category).sorted('name'),
 *   keyPaths: ["name"]
 * }, [category]);
 * ```
 * @param options
 * @param options.type - The object type, depicted by a string or a class extending Realm.Object
 * @param options.query - A function that takes a {@link Realm.Collection} and returns a {@link Realm.Collection} of the same type. This allows for filtering and sorting of the collection, before it is returned.
 * @param options.keyPaths - Indicates a lower bound on the changes relevant for the hook. This is a lower bound, since if multiple hooks add listeners (each with their own `keyPaths`) the union of these key-paths will determine the changes that are considered relevant for all listeners registered on the collection. In other words: A listener might fire and cause a re-render more than the key-paths specify, if other listeners with different key-paths are present.
 * @param deps - An array of dependencies that will be passed to {@link React.useMemo}
 * @returns a collection of realm objects or an empty array
 */
const useQuery = defaultContext.useQuery;
/**
 * Returns a {@link Realm.Object} from a given type and value of primary key.
 * The hook will update on any changes to the properties on the returned object
 * and return null if it either doesn't exists or has been deleted.
 * @example
 * ```
 * const object = useObject(ObjectClass, objectId);
 * ```
 * @param type - The object type, depicted by a string or a class extending {@link Realm.Object}
 * @param primaryKey - The primary key of the desired object which will be retrieved using {@link Realm.objectForPrimaryKey}
 * @param keyPaths - Indicates a lower bound on the changes relevant for the hook. This is a lower bound, since if multiple hooks add listeners (each with their own `keyPaths`) the union of these key-paths will determine the changes that are considered relevant for all listeners registered on the object. In other words: A listener might fire and cause a re-render more than the key-paths specify, if other listeners with different key-paths are present.
 * @returns either the desired {@link Realm.Object} or `null` in the case of it being deleted or not existing.
 */
const useObject = defaultContext.useObject;
/**
 * Returns the value representing the progress for a given {@link Realm.ProgressDirection}
 * and {@link Realm.ProgressMode}. The hook will register a progress notifier and update from
 * any changes from it.
 * @example
 * ```
 * const progress = useProgress({ direction: ProgressDirection.Download, mode: ProgressMode.ReportIndefinitely });
 * return <Text>Loading: {(100 * progress).toFixed()}%</Text>;
 * ```
 * @param options
 * @param options.direction - The {@link Realm.ProgressDirection} for the progress notifier.
 * @param options.mode - The {@link Realm.ProgressMode} for the progress notifier.
 * @returns a number between 0 and 1 representing the progress
 */
const useProgress = defaultContext.useProgress;

exports.Realm = Realm;
exports.AppProvider = AppProvider;
exports.AuthError = AuthError;
exports.RealmProvider = RealmProvider;
exports.UserProvider = UserProvider;
exports.createRealmContext = createRealmContext;
exports.createUseObject = createUseObject;
exports.createUseQuery = createUseQuery;
exports.useApp = useApp;
exports.useAuth = useAuth;
exports.useAuthResult = useAuthResult;
exports.useEmailPasswordAuth = useEmailPasswordAuth;
exports.useObject = useObject;
exports.useProgress = useProgress;
exports.useQuery = useQuery;
exports.useRealm = useRealm;
exports.useUser = useUser;
//# sourceMappingURL=index.cjs.map
